<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    

    <script>


//变量的命名规则
  // 字母，数字，"_","$"
  // 不能以数字
  // 不能是js标准中的关键字或者保留字
  //驼峰命名法  worldHello
  //所有UTF-8的内容都可以作为标识变量包括中文
//数据类型
  //String,number,boolean,null,undefined(前几种均为基本数据类型),0bject(引用数据类型) 后新增一个 symbol
  //在字符串中使用\作为转义字符
    //   在js中所有数值都是number类型 包括整数和float
    //   var a="123" String;
    //   var a=123 Number
    //   var a="123.3" number

    // typeof 为检查类型  
    // typeof a;
    // console.log(typeof a);
       // Number.MAX_VALUE 
        //    MIN  表示最大值和最小值
    // typeof在检查infinted 和 -Infinity 也为number 正无穷和负无穷
    // 若 "avc"*"dsd" 返回NAN  是一个特殊数字表示不是数字 NOT A NUMBER
    // 整数运算基本保证精度 浮点不一定
    // 使用typeof检查null时返回 Object
//强制类型转换
//  toString()该方法不影响原来的变量 转换结果返回 null和undefined没有该方法 会报错
// var a=21； a.tostring();转换为字符串
// a=a.tostring()；
// 方法二,调用 string(参数) 也可转为字符串  其中 null和undefined 也可以使用  对于number和boolean实际上就是调用tostring()


// 转换数值类型
    // 使用number（）；
    // var a="avc";
    // a=Number(a); 结果为NaN
 //若有非数值内容转为"NaN" 非数值都转为这个
 //空串转为 a=""  0
 //  true->1 false->0;
 //若为纯数字的字符串"123" ->123
 //undefined->"nan"
//方法二, 使用 parseInt(),parsefloat() 转换为数值和浮点数   将有效数字取出，但如果是 var a="b234T" 为"NAN var a="3332T" = 3332
// 如果对非字符串类型使用以上两种方法先转换为STring再转换为数字
// 在js中表示16进制数字为0X开头
// 8进制为0开头  但是有些浏览器会将8进制当成十进制来算  例如  070=70
// 2进制为0b开头但不是所有浏览器都支持
// 以上输出结果都是十进制数
// 可以在parseint中指定进制数 在第二个参数中可以解决 parseint（a,0x);


//调用boolean（）将其转化为boolean值
        //除了0和NAN,null,空串，undefined 其余的全为true 对象也为true(object)
            //    var a=123;
            //    var b=Infinity;
            //    var c=null;
            //    console.log(Boolean(a));
            //    console.log(Boolean(b));
            //    console.log(Boolean(c));
        
        
//运算符运算，typeof也为运算符，将其类型以字符串形式返回。
        //算数运算符，当对不是Number类型的值进行运算时，会将这些值转换为Number然后再运算
        //例如，true+false= 1+0；
        //任何值和NAN做运算最后结果都为NAN；
            // var c=133;
            // c=c+""; //可以用这种方法将任意数据类型加一个空串即可将其转为String 是一种隐式类型转换，由浏览器自动完成，实际上也是调用String；
            // var string="123"+"456";//为拼接运算。字符串。
            // var result=true+false;
            // var f=true+"hello"; //truehello
            // var e=123+"1"; //任何值和字符串相加都会转成字符串相加
            // console.log(e); 
            // console.log(result);
            // result=1+2+"3"; // 33 
            // result="1"+2+3 //123  算术运算符运算顺序从左往右。
                    //这里是+法转换为string 为1001 减法为99；
                        // var result=100-"1";console.log(result);  //99
                        // var result=2*"8";console.log(result); //16

                //任何值做- * /运算时都会自动转换为number
        
//一元运算符
        //可以对一个其他数值类型（非NUMBER）使用+ 将其转换为number 原理和number一样
        // var a="18";
        // a=+a;//18 
        // var res=1+"2"+3; //123
        // var resd=1+ +"2"+3; //6 一元运算符
        // console.log(resd);
//自增自减   
    // var d=20; d--;// 19;  运算完再-
    // var d=20; --d; //19   先-再运算
    // var res= d++ + ++d +d; //21 +  21+1  +22 = 64
    // console.log(d);
    // var n1=10;
    // var n2=20;
    // var n=n1++; console.log(n) //先运算完再+ n=10
    // console.log(n1++);
//逻辑运算
        //如果对非boolean值进行运算先会转换为boolean再运算
            // var a=1;
            // a=!1; //fasle
            // console.log(a);
            // var a=true;
            //  a=!!a;console.log(a); //两次取反不会有变化。
            // var result=1&&2;console.log(result); //2  如果两个值都为true则返回后边的
            // var res=0&&2; console.log(res); //0
            // var result=1||NAN;console.log(result); //空串为false;


//赋值运算符
        //result=5>4  //true;
        //对于非数值情况 先将其转换为数值再进行boolean运算
        //    console.log(1>"d"); //false;
        //    console.log(1>null);//true;
        //任何值和NAN比较都是false;
        // console.log("11"<"5"); //false 符号两侧的值都是字符串则根据boolean运算 1<1；
        // console.log("a"<"b");//true  比较字符串时是根据ASCII编码进行比较；一位一位比较 如果两位一样则比较下一位
        // console.log("avc"<"dsD");//true
        // console.log("考">"你");//比较中文没有意义；都是true
        //比较两个字符串型的数字可能会得到不可预期的结果 一定要转型 要改为"5"
        // console.log("12355"<5);
        //    console.log(1>=true) ;//true;


//unicode 编码 使用 &#  <h1>&#10</h1>

// 相等运算符
        // 比较两个值是否相等 使用==
        // =是赋值运算符
        //若比较时值不同，则先转换为相同的类型再比较
        // console.log(true=="1");//true;
        // console.log(null==0);//false; 没转换成 特殊情况 如果null转换成number就相等
        // undefined 衍生自null
        // 当两个作比较时返回true  console.log(undefinded==null) //true
        //nan 不和任何值相等包括他本身
        // console.log(NAN==NAN);//fasle;
            //判断B的值是不是NAN
            //   可以通过isNan()函数判断是不是NAN
            // var b=NaN;
            //  console.log(Nan==Nan)//不可以使用这种方式
            // console.log(isNaN(b));//true;
        //===全等运算符。  不同在于，他会判断值的类型是不是一样若值一样  类型不一样则返回false；
        //不会进行转换。

//条件运算符
//   三元运算符
//   条件表达式?语句1:语句2
        // 若为true执行1 false执行2
        // var max=a>b?(a>c?a:c):(b>c?b:c);
// 运算符优先级
            //运算符 , 用于分割语句
            // 使用时可以同时声明多个变量
            // var a=1,b=2;
        // js运算符先乘除后加减
                        //   运算符                                   	描述
                        // . [] ()           	                字段访问、数组下标、函数调用以及表达式分组
                        // ++ -- - ~ ! delete new typeof void	一元运算符、返回数据类型、对象创建、未定义值
                        // * / %	                            乘法、除法、取模
                        // + - +	                            加法、减法、字符串连接
                        // << >> >>>	                        移位
                        // < <= > >= instanceof	                小于、小于等于、大于、大于等于、instanceof
                        // == != === !==	                    等于、不等于、严格相等、非严格相等
                        // &	                                按位与
                        // ^	                                按位异或
                        // |	                                按位或
                        // &&	                                逻辑与
                        // ||	                                逻辑或
                        // ?:	                                条件
                        // = oP=	                            赋值、运算赋值
                        // ,	                                多重求值

//条件判断语句
// if(){

// }else{

// }

// if(){

// }else if(){1

    
// }else if(){

// }else{

// }

//键盘输入函数
                    //  prompt() 为键盘输入函数  返回的值是string类型的
                // var a=prompt(); prompt("请输入");
                // console.log(a);



//条件分支 switch
//假设第一条合格了 后面的全合格，进行全等比较。 defualt默认 若都不满足则之间显示默认的 break可以用来退出switch语句 就是当满足某个时则就停止后面的
// switch(num){
//     case 语句:
// }

//while 循环
    // while（条件表达式）{
        // 语句
    // }
    // 先对条件表达式进行求值判断，如果为true之行判断，如果执行完毕后继续对表达式进行判断，如果为true继续执行循环体以此类推
    //如果为false 则终止循环  先判断后执行

    // do...while循环
    //  do{
        // 语句              //先执行后判断
    //  }while（条件判断）；  //无论条件是否满足都先执行一次。


//创建对象  使用new关键字调用函数，
// 语法:对象.属性名

// 这种也可创建一个对象
// var obj={}；
// 可以直接指定其属性  使用,隔开
// var ov={
    // name:"asd",
    // wo:"asdasd"};

// var obj=new Object();
// obj.name="123";
// console.log(obj.name);
// obj["123"]=789; //可以修改属性名

// 也可以继承对象
// var obj= new Object();
// obj.name="qwe";
// obj.qwe="qwee";
// var obj2= obj;
// console.log(obj2);
                //in 属性  可以检查一个对象中是否有指定属性
                // console.log("test" in obj);


//js基本数据类型的变量都是保存在栈内存中的， 值和值之间是独立存在的，修改一个变量不会改变其他变量。
//对象是保存到堆内存中的，每创建一个新的对象，就会在堆内存中开辟出一个新的空间
// 而变量保存的是对象的内存地址。如果两个变量保存的是同一个对象的引用，当一个通过一个变量修改属性时，另一个也会受到影响

//当比较两个基本上数据的类型值是就是比较值
//当比较两个引用数据对象时，他们比较的是对象的内存地址
//如果两个对象是一摸一样的 但是地址不同，还是会返回false


//函数的参数
//形参
//  function sum(a,b){
   
//  }
// sum(1,2);
     //调用函数时，调用函数的解析器不会检查实参的类型，可能会接收到非法的参数，如果可以要对参数类型尽心检查
     //调用函数时也不会检查实参的数量；多余的实参不会被赋值
     //如果实参数量少于形参数量，少的那个形参会是未定义状态
     //函数的实参可以是任意的数据类型
     //实参可以是函数也可以是对象。
     //返回值可以是任意的数据类型也可以是一个对象




// 立即执行函数
    //  函数定义完立即被调用
    //  立即执行函数往往只会执行一次
    //   (function(){
    //   alert("woshi");
    //   })();
    //   对象的属性值可以是任何类型，也可以是个函数
    //   obj.sayName=function (){
    //   console.log("obj.name");
    //   }
    //   obj.sayName(); //调方法；

    //  function fun(){
    //   console.log(obj.name);
    //  }
    //   fun();  //调函数 没有本质的差别

    //  var obj={
    //  name:"asd",
    //  sayname:function(){
    //  console.log("ad");
    //  }
    //  }
    //  obj.sayname();


//枚举对象中的属性
 //for in 语句
 // for(var 变量 in 对象){}
 //把对象中所有语句给取出来
 //有几个对象循环体执行几次
 //每次执行时会将对象的一个属性的名字 赋值给变量
    //   var obj={
    //   name:"asd"
    //   }
    // for (var n in obj){
        // console.log("hello");
    // }

//作用域
//全局作用域 函数作用域 es新增块作用域
//全局作用域的变量都是全局变量，在页面的任意部分都可以访问的到。
//全局作用域中有一个全局对象window，由浏览器创建可以直接使用
        //  console.log(window);
        //在全局作用域中 创建的变量都会作为window对象的属性保存
        //    function fun(){
            //    console.log("sd");
        //    }
        //    fun(); //作为window对象的方法保存 
        //    window.fun(); //实际上是一样的
        //创建的函数都会作为window对象的方法保存
        //   var a=10; 
        //   console.log(window.a);


        // console.log("a="+a);
        // var a=213; //变量提升 声明提前 使用var关键字声明的变量会在代码执行之前被声明 如果不适用var 则不会提前
        //函数的声明提前 使用函数声明形式创建的函数 function 函数名(){}  创建的函数 它会在所有的代码执行之前就被创建。
        //var 关键字会声明提前 但不会初始化
        //使用函数表达式创建的函数则不会 例如  var fun2=function(){};

//函数作用域
//调用函数创建函数作用域，函数执行完毕后，函数作用域销毁
//每调用一次函数就会创建一个新的函数作用域，他们之间是互相独立的 
//函数作用域中可以访问全局变量 但是反过来不行
// 当在函数作用域中操作一个变量时 会现在自身作用域中寻找，有直接使用 无则向上一级作用域中寻找，就近原则  闭包
//在函数中 要访问全局变量可以使用window对象
//在函数作用域中叶有声明提前的特性 
// 使用var关键字声明的变量会在所有函数中的代码执行之前被声明。
//在函数中 不用var声明的变量都会成为全局变量
    // function fun(){

    //  }
    //  fun(); //独立的
    //  fun(); //独立的
    //  fun(); //独立的


    // var a=10;//全局变量
    // function fun(){
        // console.log(a);
    // }
    // fun();

    //闭包 会向上一级查找 直到找到全局作用域
    // function fun(){
        // var a=10;
        // function fun2(){
            // console.log(a);
            // c=10; //全局变量 相当于window.c=10；
        // }
        // fun2();
        // console.log(c); //访问全局变量
    // }
    // fun();

    // 定义形参就相当于在函数作用域中声明了变量
    // function fun6(e){
        // alert(e);
    // }
    // fun6();

//this
</script>
</body>
</html>
